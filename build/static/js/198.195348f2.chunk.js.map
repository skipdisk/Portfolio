{"version":3,"file":"static/js/198.195348f2.chunk.js","mappings":"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","sources":["visualizer/components/visualizers/sphere/base.tsx","visualizer/components/visualizers/sphere/reactive.tsx","../node_modules/three/examples/jsm/math/Lut.js"],"sourcesContent":["import { useFrame } from \"@react-three/fiber\";\nimport { useEffect, useMemo, useRef } from \"react\";\nimport { BoxGeometry, InstancedMesh, Matrix4, MeshBasicMaterial } from \"three\";\nimport { Lut } from \"three/examples/jsm/math/Lut\";\nimport {\n  COORDINATE_TYPE,\n  ICoordinateMapper,\n  TWO_PI,\n} from \"../../coordinateMappers/common\";\n\n// const MAPPING_MODE_POLAR_2D = \"polar_2d\";\n// const MAPPING_MODE_POLAR_PHI = \"polar_phi\";\n// const MAPPING_MODE_POLAR_THETA = \"polar_theta\";\n\ninterface BaseSphereProps {\n  coordinateMapper: ICoordinateMapper;\n  radius?: number;\n  nPoints?: number;\n  cubeSideLength?: number;\n  colorLut?: string;\n}\n\nconst BaseSphere = ({\n  coordinateMapper,\n  radius = 2,\n  nPoints = 800,\n  cubeSideLength = 0.05,\n  colorLut = \"cooltowarm\",\n}: BaseSphereProps): JSX.Element => {\n  const meshRef = useRef<InstancedMesh>(null!);\n  const tmpMatrix = useMemo(() => new Matrix4(), []);\n\n  // Recolor\n  useEffect(() => {\n    const lut = new Lut(colorLut);\n    for (let i = 0; i < nPoints; i++) {\n      meshRef.current.setColorAt(i, lut.getColor(i / nPoints));\n    }\n    meshRef.current.instanceColor!.needsUpdate = true;\n  });\n\n  useFrame(({ clock }) => {\n    // in ms\n    const elapsedTimeSec = clock.getElapsedTime();\n    let k, phi, theta, x, y, z, effectiveRadius;\n    for (let i = 0; i < nPoints; i++) {\n      k = i + 0.5;\n      // range 0:PI\n      phi = Math.acos(1 - (2 * k) / nPoints) % Math.PI;\n      // range 0:2PI\n      theta = (Math.PI * (1 + Math.sqrt(5)) * k) % TWO_PI;\n      x = Math.cos(theta) * Math.sin(phi);\n      y = Math.sin(theta) * Math.sin(phi);\n      z = Math.cos(phi);\n\n      effectiveRadius =\n        radius +\n        0.25 *\n          radius *\n          coordinateMapper.map(\n            COORDINATE_TYPE.POLAR,\n            theta / TWO_PI, // normalize\n            phi / Math.PI, // normalize\n            0,\n            elapsedTimeSec\n          );\n\n      meshRef.current.setMatrixAt(\n        i,\n        tmpMatrix.setPosition(\n          x * effectiveRadius,\n          y * effectiveRadius,\n          z * effectiveRadius\n        )\n      );\n    }\n\n    // Update the instance\n    meshRef.current.instanceMatrix!.needsUpdate = true;\n  });\n\n  return (\n    <instancedMesh\n      ref={meshRef}\n      castShadow={true}\n      receiveShadow={true}\n      args={[new BoxGeometry(), new MeshBasicMaterial(), nPoints]}\n    >\n      <boxGeometry\n        attach=\"geometry\"\n        args={[cubeSideLength, cubeSideLength, cubeSideLength, 1]}\n      />\n      <meshBasicMaterial attach=\"material\" color={\"white\"} toneMapped={false} />\n    </instancedMesh>\n  );\n};\n\nexport default BaseSphere;\n","import { folder, useControls } from \"leva\";\nimport { Vector3 } from \"three\";\nimport Ground from \"../../ground\";\nimport BaseSphere from \"./base\";\nimport { VisualProps } from \"../common\";\n\nconst SphereVisual = ({ coordinateMapper }: VisualProps): JSX.Element => {\n  const {\n    radius,\n    nPoints,\n    cubeSideLength,\n    // mapMode\n  } = useControls({\n    \"Visual - Sphere\": folder(\n      {\n        radius: { value: 2, min: 0.25, max: 3, step: 0.25 },\n        nPoints: { value: 800, min: 100, max: 2000, step: 25 },\n        cubeSideLength: {\n          value: 0.05,\n          min: 0.01,\n          max: 0.5,\n          step: 0.005,\n        },\n        // mapMode: {\n        //   value: MAPPING_MODE_POLAR_2D,\n        //   options: [\n        //     MAPPING_MODE_POLAR_2D,\n        //     MAPPING_MODE_POLAR_PHI,\n        //     MAPPING_MODE_POLAR_THETA,\n        //   ],\n        // },\n      },\n      { collapsed: true }\n    ),\n  });\n\n  return (\n    <>\n      <BaseSphere\n        coordinateMapper={coordinateMapper}\n        radius={radius}\n        nPoints={nPoints}\n        cubeSideLength={cubeSideLength}\n      />\n      <Ground\n        position={\n          new Vector3(0, 0, -radius * (1 + 0.25 * coordinateMapper.amplitude))\n        }\n      />\n    </>\n  );\n};\n\nexport default SphereVisual;\n","import {\n\tColor,\n\tMathUtils\n} from 'three';\n\nclass Lut {\n\n \tconstructor( colormap, count = 32 ) {\n\n\t\tthis.isLut = true;\n\n\t\tthis.lut = [];\n\t\tthis.map = [];\n\t\tthis.n = 0;\n\t\tthis.minV = 0;\n\t\tthis.maxV = 1;\n\n\t\tthis.setColorMap( colormap, count );\n\n\t}\n\n\tset( value ) {\n\n\t\tif ( value.isLut === true ) {\n\n\t\t\tthis.copy( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetMin( min ) {\n\n\t\tthis.minV = min;\n\n\t\treturn this;\n\n\t}\n\n\tsetMax( max ) {\n\n\t\tthis.maxV = max;\n\n\t\treturn this;\n\n\t}\n\n\tsetColorMap( colormap, count = 32 ) {\n\n\t\tthis.map = ColorMapKeywords[ colormap ] || ColorMapKeywords.rainbow;\n\t\tthis.n = count;\n\n\t\tconst step = 1.0 / this.n;\n\t\tconst minColor = new Color();\n\t\tconst maxColor = new Color();\n\n\t\tthis.lut.length = 0;\n\n\t\t// sample at 0\n\n\t\tthis.lut.push( new Color( this.map[ 0 ][ 1 ] ) );\n\n\t\t// sample at 1/n, ..., (n-1)/n\n\n\t\tfor ( let i = 1; i < count; i ++ ) {\n\n\t\t\tconst alpha = i * step;\n\n\t\t\tfor ( let j = 0; j < this.map.length - 1; j ++ ) {\n\n\t\t\t\tif ( alpha > this.map[ j ][ 0 ] && alpha <= this.map[ j + 1 ][ 0 ] ) {\n\n\t\t\t\t\tconst min = this.map[ j ][ 0 ];\n\t\t\t\t\tconst max = this.map[ j + 1 ][ 0 ];\n\n\t\t\t\t\tminColor.set( this.map[ j ][ 1 ] );\n\t\t\t\t\tmaxColor.set( this.map[ j + 1 ][ 1 ] );\n\n\t\t\t\t\tconst color = new Color().lerpColors( minColor, maxColor, ( alpha - min ) / ( max - min ) );\n\n\t\t\t\t\tthis.lut.push( color );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// sample at 1\n\n\t\tthis.lut.push( new Color( this.map[ this.map.length - 1 ][ 1 ] ) );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( lut ) {\n\n\t\tthis.lut = lut.lut;\n\t\tthis.map = lut.map;\n\t\tthis.n = lut.n;\n\t\tthis.minV = lut.minV;\n\t\tthis.maxV = lut.maxV;\n\n\t\treturn this;\n\n\t}\n\n\tgetColor( alpha ) {\n\n\t\talpha = MathUtils.clamp( alpha, this.minV, this.maxV );\n\n\t\talpha = ( alpha - this.minV ) / ( this.maxV - this.minV );\n\n\t\tconst colorPosition = Math.round( alpha * this.n );\n\n\t\treturn this.lut[ colorPosition ];\n\n\t}\n\n\taddColorMap( name, arrayOfColors ) {\n\n\t\tColorMapKeywords[ name ] = arrayOfColors;\n\n\t\treturn this;\n\n\t}\n\n\tcreateCanvas() {\n\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = 1;\n\t\tcanvas.height = this.n;\n\n\t\tthis.updateCanvas( canvas );\n\n\t\treturn canvas;\n\n\t}\n\n\tupdateCanvas( canvas ) {\n\n\t\tconst ctx = canvas.getContext( '2d', { alpha: false } );\n\n\t\tconst imageData = ctx.getImageData( 0, 0, 1, this.n );\n\n\t\tconst data = imageData.data;\n\n\t\tlet k = 0;\n\n\t\tconst step = 1.0 / this.n;\n\n\t\tconst minColor = new Color();\n\t\tconst maxColor = new Color();\n\t\tconst finalColor = new Color();\n\n\t\tfor ( let i = 1; i >= 0; i -= step ) {\n\n\t\t\tfor ( let j = this.map.length - 1; j >= 0; j -- ) {\n\n\t\t\t\tif ( i < this.map[ j ][ 0 ] && i >= this.map[ j - 1 ][ 0 ] ) {\n\n\t\t\t\t\tconst min = this.map[ j - 1 ][ 0 ];\n\t\t\t\t\tconst max = this.map[ j ][ 0 ];\n\n\t\t\t\t\tminColor.set( this.map[ j - 1 ][ 1 ] );\n\t\t\t\t\tmaxColor.set( this.map[ j ][ 1 ] );\n\n\t\t\t\t\tfinalColor.lerpColors( minColor, maxColor, ( i - min ) / ( max - min ) );\n\n\t\t\t\t\tdata[ k * 4 ] = Math.round( finalColor.r * 255 );\n\t\t\t\t\tdata[ k * 4 + 1 ] = Math.round( finalColor.g * 255 );\n\t\t\t\t\tdata[ k * 4 + 2 ] = Math.round( finalColor.b * 255 );\n\t\t\t\t\tdata[ k * 4 + 3 ] = 255;\n\n\t\t\t\t\tk += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tctx.putImageData( imageData, 0, 0 );\n\n\t\treturn canvas;\n\n\t}\n\n}\n\nconst ColorMapKeywords = {\n\n\t'rainbow': [[ 0.0, 0x0000FF ], [ 0.2, 0x00FFFF ], [ 0.5, 0x00FF00 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFF0000 ]],\n\t'cooltowarm': [[ 0.0, 0x3C4EC2 ], [ 0.2, 0x9BBCFF ], [ 0.5, 0xDCDCDC ], [ 0.8, 0xF6A385 ], [ 1.0, 0xB40426 ]],\n\t'blackbody': [[ 0.0, 0x000000 ], [ 0.2, 0x780000 ], [ 0.5, 0xE63200 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFFFFFF ]],\n\t'grayscale': [[ 0.0, 0x000000 ], [ 0.2, 0x404040 ], [ 0.5, 0x7F7F80 ], [ 0.8, 0xBFBFBF ], [ 1.0, 0xFFFFFF ]]\n\n};\n\nexport { Lut, ColorMapKeywords };\n"],"names":["coordinateMapper","radius","nPoints","cubeSideLength","colorLut","meshRef","useRef","tmpMatrix","useMemo","Matrix4","useEffect","lut","Lut","i","current","setColorAt","getColor","instanceColor","needsUpdate","useFrame","k","phi","theta","x","y","z","effectiveRadius","elapsedTimeSec","clock","getElapsedTime","Math","acos","PI","sqrt","TWO_PI","cos","sin","map","COORDINATE_TYPE","setMatrixAt","setPosition","instanceMatrix","ref","castShadow","receiveShadow","args","BoxGeometry","MeshBasicMaterial","attach","color","toneMapped","useControls","folder","value","min","max","step","collapsed","position","Vector3","amplitude","colormap","count","this","isLut","n","minV","maxV","setColorMap","copy","ColorMapKeywords","rainbow","minColor","Color","maxColor","length","push","alpha","j","set","lerpColors","MathUtils","colorPosition","round","name","arrayOfColors","canvas","document","createElement","width","height","updateCanvas","ctx","getContext","imageData","getImageData","data","finalColor","r","g","b","putImageData"],"sourceRoot":""}