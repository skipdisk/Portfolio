{"version":3,"file":"static/js/708.01289804.chunk.js","mappings":"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","sources":["visualizer/components/visualizers/cube/base.tsx","visualizer/components/visualizers/cube/reactive.tsx","../node_modules/three/examples/jsm/math/Lut.js"],"sourcesContent":["import { useRef, useEffect, useMemo } from \"react\";\nimport { useFrame } from \"@react-three/fiber\";\nimport { Lut } from \"three/examples/jsm/math/Lut.js\";\nimport { BoxGeometry, InstancedMesh, Matrix4, MeshBasicMaterial } from \"three\";\nimport {\n  ICoordinateMapper,\n  HALF_DIAGONAL_UNIT_SQUARE,\n  COORDINATE_TYPE,\n} from \"../../coordinateMappers/common\";\n\ninterface BaseCubeProps {\n  coordinateMapper: ICoordinateMapper;\n  nPerSide?: number;\n  cubeSideLength?: number;\n  cubeSpacingScalar?: number;\n  volume?: boolean;\n  colorLut?: string;\n}\n\nconst BaseCube = ({\n  coordinateMapper,\n  nPerSide = 10,\n  cubeSideLength = 0.5,\n  cubeSpacingScalar = 0.5,\n  volume = true,\n  colorLut = \"cooltowarm\",\n}: BaseCubeProps): JSX.Element => {\n  const meshRef = useRef<InstancedMesh>(null!);\n  const tmpMatrix = useMemo(() => new Matrix4(), []);\n  const inputCoordinateType = volume\n    ? COORDINATE_TYPE.CARTESIAN_3D\n    : COORDINATE_TYPE.CARTESIAN_CUBE_FACES;\n\n  // Recolor\n  useEffect(() => {\n    const lut = new Lut(colorLut);\n    let instanceIdx, normCubeX, normCubeY, normCubeZ, normRadialOffset;\n    // interior\n    for (let row = 0; row < nPerSide; row++) {\n      for (let col = 0; col < nPerSide; col++) {\n        for (let depth = 0; depth < nPerSide; depth++) {\n          instanceIdx = row * nPerSide ** 2 + col * nPerSide + depth;\n          normCubeX = row / (nPerSide - 1);\n          normCubeY = col / (nPerSide - 1);\n          normCubeZ = depth / (nPerSide - 1);\n          // Exterior:\n          if (normCubeX == 0 || normCubeX == 1) {\n            normRadialOffset =\n              Math.hypot(normCubeY - 0.5, normCubeZ - 0.5) /\n              HALF_DIAGONAL_UNIT_SQUARE;\n          } else if (normCubeY == 0 || normCubeY == 1) {\n            normRadialOffset =\n              Math.hypot(normCubeX - 0.5, normCubeZ - 0.5) /\n              HALF_DIAGONAL_UNIT_SQUARE;\n          } else if (normCubeZ == 0 || normCubeZ == 1) {\n            normRadialOffset =\n              Math.hypot(normCubeX - 0.5, normCubeY - 0.5) /\n              HALF_DIAGONAL_UNIT_SQUARE;\n          } else {\n            // interior\n            normRadialOffset = 0;\n          }\n          meshRef.current.setColorAt(\n            instanceIdx,\n            lut.getColor(normRadialOffset)\n          );\n        }\n      }\n    }\n    meshRef.current.instanceColor!.needsUpdate = true;\n  });\n\n  useFrame(({ clock }) => {\n    //in ms\n    const elapsedTimeSec = clock.getElapsedTime();\n    const faceSize = nPerSide * (1 + cubeSpacingScalar) * cubeSideLength;\n    let instanceIdx, normCubeX, normCubeY, normCubeZ, x, y, z, normalizedScale;\n    for (let row = 0; row < nPerSide; row++) {\n      for (let col = 0; col < nPerSide; col++) {\n        for (let depth = 0; depth < nPerSide; depth++) {\n          instanceIdx = row * nPerSide ** 2 + col * nPerSide + depth;\n          normCubeX = row / (nPerSide - 1);\n          normCubeY = col / (nPerSide - 1);\n          normCubeZ = depth / (nPerSide - 1);\n          x = faceSize * (normCubeX - 0.5);\n          y = faceSize * (normCubeY - 0.5);\n          z = faceSize * (normCubeZ - 0.5);\n          // Position\n          tmpMatrix.setPosition(x, y, z);\n\n          // Scale\n          normalizedScale =\n            0.1 +\n            0.5 *\n              coordinateMapper.map(\n                inputCoordinateType,\n                normCubeX,\n                normCubeY,\n                normCubeZ,\n                elapsedTimeSec\n              );\n          tmpMatrix.elements[0] = normalizedScale;\n          tmpMatrix.elements[5] = normalizedScale;\n          tmpMatrix.elements[10] = normalizedScale;\n          meshRef.current.setMatrixAt(instanceIdx, tmpMatrix);\n        }\n      }\n    }\n    // Update the instance\n    meshRef.current.instanceMatrix!.needsUpdate = true;\n  });\n\n  return (\n    <instancedMesh\n      ref={meshRef}\n      castShadow={true}\n      receiveShadow={true}\n      args={[new BoxGeometry(), new MeshBasicMaterial(), nPerSide ** 3]}\n    >\n      <boxGeometry\n        attach=\"geometry\"\n        args={[cubeSideLength, cubeSideLength, cubeSideLength, 1]}\n      />\n      <meshBasicMaterial\n        attach=\"material\"\n        color={\"#670092\"}\n        toneMapped={false}\n      />\n    </instancedMesh>\n  );\n};\n\nexport default BaseCube;\n","import { folder, useControls } from \"leva\";\nimport { Vector3 } from \"three\";\nimport Ground from \"../../ground\";\nimport BaseCube from \"./base\";\nimport { VisualProps } from \"../common\";\n\nconst CubeVisual = ({ coordinateMapper }: VisualProps): JSX.Element => {\n  const { nPerSide, cubeUnitSideLength, cubeUnitSpacingScalar, volume } =\n    useControls({\n      \"Visual - Cube\": folder(\n        {\n          nPerSide: {\n            value: 10,\n            min: 3,\n            max: 50,\n            step: 1,\n          },\n          cubeUnitSideLength: {\n            value: 0.5,\n            min: 0.1,\n            max: 2.0,\n            step: 0.05,\n          },\n          cubeUnitSpacingScalar: {\n            value: 0.1,\n            min: 0,\n            max: 2,\n            step: 0.1,\n          },\n          volume: true,\n        },\n        { collapsed: true }\n      ),\n    });\n\n  return (\n    <>\n      <BaseCube\n        coordinateMapper={coordinateMapper}\n        nPerSide={nPerSide}\n        cubeSideLength={cubeUnitSideLength}\n        cubeSpacingScalar={cubeUnitSpacingScalar}\n        volume={volume}\n      />\n      <Ground\n        position={\n          new Vector3(\n            0,\n            0,\n            -0.75 * nPerSide * (1 + cubeUnitSpacingScalar) * cubeUnitSideLength\n          )\n        }\n      />\n    </>\n  );\n};\n\nexport default CubeVisual;\n","import {\n\tColor,\n\tMathUtils\n} from 'three';\n\nclass Lut {\n\n \tconstructor( colormap, count = 32 ) {\n\n\t\tthis.isLut = true;\n\n\t\tthis.lut = [];\n\t\tthis.map = [];\n\t\tthis.n = 0;\n\t\tthis.minV = 0;\n\t\tthis.maxV = 1;\n\n\t\tthis.setColorMap( colormap, count );\n\n\t}\n\n\tset( value ) {\n\n\t\tif ( value.isLut === true ) {\n\n\t\t\tthis.copy( value );\n\n\t\t}\n\n\t\treturn this;\n\n\t}\n\n\tsetMin( min ) {\n\n\t\tthis.minV = min;\n\n\t\treturn this;\n\n\t}\n\n\tsetMax( max ) {\n\n\t\tthis.maxV = max;\n\n\t\treturn this;\n\n\t}\n\n\tsetColorMap( colormap, count = 32 ) {\n\n\t\tthis.map = ColorMapKeywords[ colormap ] || ColorMapKeywords.rainbow;\n\t\tthis.n = count;\n\n\t\tconst step = 1.0 / this.n;\n\t\tconst minColor = new Color();\n\t\tconst maxColor = new Color();\n\n\t\tthis.lut.length = 0;\n\n\t\t// sample at 0\n\n\t\tthis.lut.push( new Color( this.map[ 0 ][ 1 ] ) );\n\n\t\t// sample at 1/n, ..., (n-1)/n\n\n\t\tfor ( let i = 1; i < count; i ++ ) {\n\n\t\t\tconst alpha = i * step;\n\n\t\t\tfor ( let j = 0; j < this.map.length - 1; j ++ ) {\n\n\t\t\t\tif ( alpha > this.map[ j ][ 0 ] && alpha <= this.map[ j + 1 ][ 0 ] ) {\n\n\t\t\t\t\tconst min = this.map[ j ][ 0 ];\n\t\t\t\t\tconst max = this.map[ j + 1 ][ 0 ];\n\n\t\t\t\t\tminColor.set( this.map[ j ][ 1 ] );\n\t\t\t\t\tmaxColor.set( this.map[ j + 1 ][ 1 ] );\n\n\t\t\t\t\tconst color = new Color().lerpColors( minColor, maxColor, ( alpha - min ) / ( max - min ) );\n\n\t\t\t\t\tthis.lut.push( color );\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\t// sample at 1\n\n\t\tthis.lut.push( new Color( this.map[ this.map.length - 1 ][ 1 ] ) );\n\n\t\treturn this;\n\n\t}\n\n\tcopy( lut ) {\n\n\t\tthis.lut = lut.lut;\n\t\tthis.map = lut.map;\n\t\tthis.n = lut.n;\n\t\tthis.minV = lut.minV;\n\t\tthis.maxV = lut.maxV;\n\n\t\treturn this;\n\n\t}\n\n\tgetColor( alpha ) {\n\n\t\talpha = MathUtils.clamp( alpha, this.minV, this.maxV );\n\n\t\talpha = ( alpha - this.minV ) / ( this.maxV - this.minV );\n\n\t\tconst colorPosition = Math.round( alpha * this.n );\n\n\t\treturn this.lut[ colorPosition ];\n\n\t}\n\n\taddColorMap( name, arrayOfColors ) {\n\n\t\tColorMapKeywords[ name ] = arrayOfColors;\n\n\t\treturn this;\n\n\t}\n\n\tcreateCanvas() {\n\n\t\tconst canvas = document.createElement( 'canvas' );\n\t\tcanvas.width = 1;\n\t\tcanvas.height = this.n;\n\n\t\tthis.updateCanvas( canvas );\n\n\t\treturn canvas;\n\n\t}\n\n\tupdateCanvas( canvas ) {\n\n\t\tconst ctx = canvas.getContext( '2d', { alpha: false } );\n\n\t\tconst imageData = ctx.getImageData( 0, 0, 1, this.n );\n\n\t\tconst data = imageData.data;\n\n\t\tlet k = 0;\n\n\t\tconst step = 1.0 / this.n;\n\n\t\tconst minColor = new Color();\n\t\tconst maxColor = new Color();\n\t\tconst finalColor = new Color();\n\n\t\tfor ( let i = 1; i >= 0; i -= step ) {\n\n\t\t\tfor ( let j = this.map.length - 1; j >= 0; j -- ) {\n\n\t\t\t\tif ( i < this.map[ j ][ 0 ] && i >= this.map[ j - 1 ][ 0 ] ) {\n\n\t\t\t\t\tconst min = this.map[ j - 1 ][ 0 ];\n\t\t\t\t\tconst max = this.map[ j ][ 0 ];\n\n\t\t\t\t\tminColor.set( this.map[ j - 1 ][ 1 ] );\n\t\t\t\t\tmaxColor.set( this.map[ j ][ 1 ] );\n\n\t\t\t\t\tfinalColor.lerpColors( minColor, maxColor, ( i - min ) / ( max - min ) );\n\n\t\t\t\t\tdata[ k * 4 ] = Math.round( finalColor.r * 255 );\n\t\t\t\t\tdata[ k * 4 + 1 ] = Math.round( finalColor.g * 255 );\n\t\t\t\t\tdata[ k * 4 + 2 ] = Math.round( finalColor.b * 255 );\n\t\t\t\t\tdata[ k * 4 + 3 ] = 255;\n\n\t\t\t\t\tk += 1;\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\t\tctx.putImageData( imageData, 0, 0 );\n\n\t\treturn canvas;\n\n\t}\n\n}\n\nconst ColorMapKeywords = {\n\n\t'rainbow': [[ 0.0, 0x0000FF ], [ 0.2, 0x00FFFF ], [ 0.5, 0x00FF00 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFF0000 ]],\n\t'cooltowarm': [[ 0.0, 0x3C4EC2 ], [ 0.2, 0x9BBCFF ], [ 0.5, 0xDCDCDC ], [ 0.8, 0xF6A385 ], [ 1.0, 0xB40426 ]],\n\t'blackbody': [[ 0.0, 0x000000 ], [ 0.2, 0x780000 ], [ 0.5, 0xE63200 ], [ 0.8, 0xFFFF00 ], [ 1.0, 0xFFFFFF ]],\n\t'grayscale': [[ 0.0, 0x000000 ], [ 0.2, 0x404040 ], [ 0.5, 0x7F7F80 ], [ 0.8, 0xBFBFBF ], [ 1.0, 0xFFFFFF ]]\n\n};\n\nexport { Lut, ColorMapKeywords };\n"],"names":["coordinateMapper","nPerSide","cubeSideLength","cubeSpacingScalar","volume","colorLut","meshRef","useRef","tmpMatrix","useMemo","Matrix4","inputCoordinateType","COORDINATE_TYPE","useEffect","instanceIdx","normCubeX","normCubeY","normCubeZ","normRadialOffset","lut","Lut","row","col","depth","Math","hypot","HALF_DIAGONAL_UNIT_SQUARE","current","setColorAt","getColor","instanceColor","needsUpdate","useFrame","x","y","z","normalizedScale","elapsedTimeSec","clock","getElapsedTime","faceSize","setPosition","map","elements","setMatrixAt","instanceMatrix","ref","castShadow","receiveShadow","args","BoxGeometry","MeshBasicMaterial","attach","color","toneMapped","useControls","folder","value","min","max","step","cubeUnitSideLength","cubeUnitSpacingScalar","collapsed","position","Vector3","colormap","count","this","isLut","n","minV","maxV","setColorMap","copy","ColorMapKeywords","rainbow","minColor","Color","maxColor","length","push","i","alpha","j","set","lerpColors","MathUtils","colorPosition","round","name","arrayOfColors","canvas","document","createElement","width","height","updateCanvas","ctx","getContext","imageData","getImageData","data","k","finalColor","r","g","b","putImageData"],"sourceRoot":""}